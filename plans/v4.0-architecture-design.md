# Pinball v4.0 - Architecture Design for Feature Parity

## 1. Architecture Overview

### 1.1 Design Principles
- **Flutter Parity**: Match Flutter I/O Pinball architecture patterns in Godot
- **Modular Zones**: Each game zone as independent, testable component
- **Signal-Driven**: Loose coupling via Godot signals (equivalent to BLoC events)
- **State Isolation**: Separate game state, UI state, and backbox state
- **Asset Management**: Organized asset loading by theme and zone

### 1.2 High-Level Architecture
```
┌─────────────────────────────────────────────────────────┐
│                    Presentation Layer                    │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │
│  │   Backbox   │  │     HUD     │  │   Overlays  │     │
│  │  Manager    │  │   (UIV4)    │  │ (Mobile UI) │     │
│  └─────────────┘  └─────────────┘  └─────────────┘     │
└─────────────────────────────────────────────────────────┘
                            │
┌─────────────────────────────────────────────────────────┐
│                    Gameplay Layer                        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │
│  │   Zones     │  │   Physics   │  │   Audio     │     │
│  │ (5 areas)   │  │  (Ball,     │  │  Manager    │     │
│  └─────────────┘  │  Flippers)  │  └─────────────┘     │
│                   └─────────────┘                       │
└─────────────────────────────────────────────────────────┘
                            │
┌─────────────────────────────────────────────────────────┐
│                    State Layer                           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │
│  │   Game      │  │   Start     │  │   Backbox   │     │
│  │  Manager    │  │   Flow      │  │   State     │     │
│  │  (V4)       │  │             │  │             │     │
│  └─────────────┘  └─────────────┘  └─────────────┘     │
└─────────────────────────────────────────────────────────┘
                            │
┌─────────────────────────────────────────────────────────┐
│                    Data Layer                            │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │
│  │   Local     │  │   Asset     │  │   Settings  │     │
│  │  Storage    │  │   Loader    │  │             │     │
│  └─────────────┘  └─────────────┘  └─────────────┘     │
└─────────────────────────────────────────────────────────┘
```

## 2. Core Component Architecture

### 2.1 GameManagerV4 (GameBloc Equivalent)
```gdscript
# Core state management (autoload singleton)
class_name GameManagerV4 extends Node

enum Status { WAITING, PLAYING, GAME_OVER }
enum Bonus { GOOGLE_WORD, DASH_NEST, SPARKY_TURBO_CHARGE, DINO_CHOMP, ANDROID_SPACESHIP }

signal scored(points: int)
signal round_lost()
signal bonus_activated(bonus: Bonus)
signal multiplier_increased()
signal game_over()
signal game_started()

# State variables
var round_score: int = 0
var total_score: int = 0
var multiplier: int = 1
var rounds: int = 3
var bonus_history: Array[Bonus] = []
var status: Status = Status.WAITING

# Methods matching Flutter GameBloc events
func add_score(points: int) -> void
func on_round_lost() -> void
func increase_multiplier() -> void
func add_bonus(bonus: Bonus) -> void
func start_game() -> void
```

### 2.2 Zone Architecture Pattern
Each game zone follows this pattern:

```gdscript
# Zone Template (e.g., AndroidAcresV4.gd)
class_name AndroidAcresV4 extends Node2D

# Zone-specific signals
signal ramp_hit(points: int)
signal bumper_hit(points: int, bumper_id: String)
signal spaceship_target_hit(points: int)

# Zone state
var ramp_hit_count: int = 0
var bumpers_lit: Dictionary = {
    "A": false,
    "B": false, 
    "COW": false
}

func _ready():
    # Connect child components
    connect_ramp()
    connect_bumpers()
    connect_spaceship()

func connect_ramp():
    var ramp = $SpaceshipRamp
    if ramp and ramp.has_signal("body_entered"):
        ramp.connect("body_entered", _on_ramp_hit)

func _on_ramp_hit(body: Node):
    if body.is_in_group("balls"):
        ramp_hit_count += 1
        GameManagerV4.add_score(5000)
        
        # Every 5 hits increases multiplier
        if ramp_hit_count % 5 == 0:
            GameManagerV4.increase_multiplier()
```

### 2.3 Signal Mapping (Flutter Events → Godot Signals)
| **Flutter Event** | **Godot Signal** | **Emitter** | **Listener** |
|------------------|-----------------|------------|-------------|
| GameStarted | game_started | GameManagerV4 | MainV4, UIV4, Camera |
| Scored(points) | scored(points) | GameManagerV4 | UIV4, ScorePopup |
| RoundLost | round_lost | GameManagerV4 | MainV4, UIV4, Launcher |
| MultiplierIncreased | multiplier_increased | GameManagerV4 | MultipliersV4, UIV4 |
| BonusActivated(bonus) | bonus_activated(bonus) | GameManagerV4 | MultiballsV4, Backbox |
| GameOver | game_over | GameManagerV4 | MainV4, BackboxManagerV4 |

## 3. Scene Hierarchy Design

### 3.1 MainV4.tscn Structure
```
MainV4 (Node2D)
├── Camera2D (CameraFocusingBehavior)
├── Playfield (Node2D)
│   ├── Background (Sprite2D)
│   ├── Boundaries (StaticBody2D)
│   ├── BackboxDisplay (CanvasLayer)
│   ├── Zones (Node2D)
│   │   ├── AndroidAcres (Node2D, script: AndroidAcresV4.gd)
│   │   │   ├── SpaceshipRamp (Area2D)
│   │   │   ├── AndroidBumperA (RigidBody2D)
│   │   │   ├── AndroidBumperB (RigidBody2D)
│   │   │   ├── AndroidBumperCow (RigidBody2D)
│   │   │   └── AndroidSpaceship (Area2D)
│   │   ├── DinoDesert (Node2D, script: DinoDesertV4.gd)
│   │   ├── GoogleGallery (Node2D, script: GoogleGalleryV4.gd)
│   │   ├── FlutterForest (Node2D, script: FlutterForestV4.gd)
│   │   ├── SparkyScorch (Node2D, script: SparkyScorchV4.gd)
│   │   ├── Multipliers (Node2D, script: MultipliersV4.gd)
│   │   └── Multiballs (Node2D, script: MultiballsV4.gd)
│   ├── Drain (Area2D, script: DrainV4.gd)
│   └── BottomGroup (Node2D)
│       ├── FlipperLeft (RigidBody2D)
│       ├── FlipperRight (RigidBody2D)
│       ├── KickerLeft (Area2D)
│       └── KickerRight (Area2D)
├── Balls (Node2D)  # Ball container
├── Launcher (Node2D, script: LauncherV4.gd)
├── UI (CanvasLayer, script: UIV4.gd)
└── Overlays (CanvasLayer)  # Mobile controls, pause menu
```

### 3.2 Zone Scene Organization
```
scenes/zones/
├── AndroidAcres/
│   ├── AndroidAcres.tscn
│   └── AndroidAcres.gd
├── DinoDesert/
│   ├── DinoDesert.tscn
│   └── DinoDesert.gd
├── GoogleGallery/
│   ├── GoogleGallery.tscn
│   └── GoogleGallery.gd
├── FlutterForest/
│   ├── FlutterForest.tscn
│   └── FlutterForest.gd
└── SparkyScorch/
    ├── SparkyScorch.tscn
    └── SparkyScorch.gd
```

## 4. State Management Architecture

### 4.1 Three-State System (Matching Flutter)
```mermaid
graph TD
    A[Start Flow] --> B[Initial State]
    B --> C[Character Select]
    C --> D[How to Play]
    D --> E[Game Playing]
    
    E --> F{Round Lost?}
    F -->|Yes| G[Update Score<br/>Decrement Rounds]
    G --> H{Rounds > 0?}
    H -->|Yes| I[Spawn New Ball]
    H -->|No| J[Game Over]
    I --> E
    
    J --> K[Backbox: Leaderboard]
    K --> L[Backbox: Initials Input]
    L --> M[Backbox: Game Over Info]
    M --> N[Backbox: Share]
    N --> O[Replay?]
    O -->|Yes| C
    O -->|No| P[Exit]
```

### 4.2 Backbox State Machine
```gdscript
# BackboxManagerV4.gd - State machine matching BackboxBloc
enum BackboxState {
    LOADING,
    LEADERBOARD_SUCCESS,
    LEADERBOARD_FAILURE,
    INITIALS_FORM,
    INITIALS_SUCCESS,
    INITIALS_FAILURE,
    SHARE
}

var current_state: BackboxState = BackboxState.LOADING
var selected_character_key: String = "sparky"  # Default

func request_initials(score: int, character: String) -> void:
    # Called when game ends
    current_state = BackboxState.INITIALS_FORM
    emit_signal("state_changed", current_state, {"score": score, "character": character})

func submit_initials(initials: String) -> void:
    # Validate and save
    if _validate_initials(initials):
        current_state = BackboxState.INITIALS_SUCCESS
        _save_to_leaderboard(initials)
    else:
        current_state = BackboxState.INITIALS_FAILURE
    emit_signal("state_changed", current_state)
```

## 5. Asset Management Architecture

### 5.1 Theme-Based Asset Loading
```
assets/
├── sprites/
│   ├── v4.0/
│   │   ├── themes/
│   │   │   ├── sparky/
│   │   │   │   ├── ball.png
│   │   │   │   ├── icon.png
│   │   │   │   ├── leaderboard_icon.png
│   │   │   │   ├── background.jpg
│   │   │   │   └── animation.png
│   │   │   ├── dino/
│   │   │   ├── dash/
│   │   │   └── android/
│   │   ├── zones/
│   │   │   ├── android_acres/
│   │   │   ├── dino_desert/
│   │   │   ├── google_gallery/
│   │   │   ├── flutter_forest/
│   │   │   └── sparky_scorch/
│   │   └── ui/
│   │       ├── backbox/
│   │       ├── score_popups/
│   │       └── buttons/
└── sounds/
    └── v4.0/
        ├── zones/
        └── ui/
```

### 5.2 Asset Loader Service
```gdscript
# AssetLoaderV4.gd - Centralized asset management
class_name AssetLoaderV4 extends Node

func load_theme_assets(theme_key: String) -> Dictionary:
    var assets = {}
    var base_path = "res://assets/sprites/v4.0/themes/%s/" % theme_key
    
    assets.ball = load("%sball.png" % base_path)
    assets.icon = load("%sicon.png" % base_path)
    assets.leaderboard_icon = load("%sleaderboard_icon.png" % base_path)
    assets.background = load("%sbackground.jpg" % base_path)
    
    return assets

func load_zone_assets(zone_key: String) -> Dictionary:
    # Load zone-specific sprites
    pass
```

## 6. Integration Patterns

### 6.1 Zone-to-GameManager Integration
```gdscript
# Example: GoogleGalleryV4.gd integration
func _on_rollover_hit(rollover_id: String):
    # Score points
    GameManagerV4.add_score(5000)
    
    # Track letter completion
    _mark_letter_lit(rollover_id)
    
    # Check for word completion
    if _is_word_complete():
        GameManagerV4.add_bonus(GameManagerV4.Bonus.GOOGLE_WORD)
        _reset_word()
```

### 6.2 Bonus System Integration
```gdscript
# GameManagerV4.gd - Bonus handling
func add_bonus(bonus: Bonus) -> void:
    bonus_history.append(bonus)
    bonus_activated.emit(bonus)
    
    # Handle bonus-specific logic
    match bonus:
        Bonus.GOOGLE_WORD, Bonus.DASH_NEST:
            # Start bonus ball timer
            bonus_ball_timer = BONUS_BALL_DELAY
        Bonus.ANDROID_SPACESHIP:
            # Add large score bonus
            add_score(200000)
        # ... other bonuses
```

### 6.3 Multiplier System Integration
```gdscript
# AndroidAcresV4.gd - Ramp multiplier tracking
func _on_ramp_hit(body: Node):
    if body.is_in_group("balls"):
        ramp_hit_count += 1
        
        # Every 5 ramp hits increases multiplier
        if ramp_hit_count % 5 == 0:
            GameManagerV4.increase_multiplier()
            
        # Update visual indicator
        _update_ramp_progress(ramp_hit_count % 5)
```

## 7. Performance Considerations

### 7.1 Optimization Strategies
1. **Object Pooling**: Reuse ball instances instead of instantiating/destroying
2. **Texture Atlases**: Combine zone sprites into texture atlases
3. **LOD System**: Simplified collision when ball is far from zone
4. **Signal Debouncing**: Limit frequent signal emissions
5. **Memory Management**: Unload unused zone assets between games

### 7.2 Ball Management
```gdscript
# BallPoolV4.gd - Object pooling for balls
class_name BallPoolV4 extends Node

var ball_pool: Array[RigidBody2D] = []
var active_balls: Array[RigidBody2D] = []

func get_ball() -> RigidBody2D:
    if ball_pool.is_empty():
        return _create_new_ball()
    else:
        var ball = ball_pool.pop_back()
        ball.show()
        ball.set_process(true)
        active_balls.append(ball)
        return ball

func return_ball(ball: RigidBody2D) -> void:
    ball.hide()
    ball.set_process(false)
    active_balls.erase(ball)
    ball_pool.append(ball)
```

## 8. Testing Architecture

### 8.1 Unit Test Structure
```
test/v4/
├── unit/
│   ├── GameManagerV4Test.gd
│   ├── ZoneTests/
│   │   ├── AndroidAcresV4Test.gd
│   │   ├── GoogleGalleryV4Test.gd
│   │   └── ...
│   └── IntegrationTests/
└── integration/
    └── GameFlowTest.gd
```

### 8.2 Mock Objects for Testing
```gdscript
# MockGameManager for zone testing
class_name MockGameManager extends Node:
    var score_added: int = 0
    var bonuses_added: Array = []
    
    func add_score(points: int) -> void:
        score_added += points
    
    func add_bonus(bonus) -> void:
        bonuses_added.append(bonus)
```

## 9. Migration Strategy

### 9.1 Incremental Implementation
1. **Phase 1**: Complete GameManagerV4 and core systems
2. **Phase 2**: Implement one zone (Android Acres) as prototype
3. **Phase 3**: Implement remaining zones
4. **Phase 4**: Integrate backbox and UI systems
5. **Phase 5**: Polish, performance, testing

### 9.2 Backward Compatibility
- Maintain v1-3 scenes and scripts unchanged
- v4.0 as separate scene tree (MainV4.tscn)
- Shared assets where possible
- Gradual migration of shared systems

---

*Architecture Version: 1.0*  
*Designed for: Godot 4.x with Flutter I/O Pinball parity*  
*Last Updated: